version: 2.1

commands:
  package_and_checksum:
    description: "Package built binary into tar.gz and generate sha256"
    parameters:
      crate_name: { type: string }
      target: { type: string }
      out_name: { type: string }
    steps:
      - run:
          name: Package << parameters.out_name >>
          command: |
            set -euxo pipefail
            CRATE="<< parameters.crate_name >>"
            TARGET="<< parameters.target >>"
            OUT="<< parameters.out_name >>"
            BIN="target/${TARGET}/release/${CRATE}"
            test -f "$BIN" || (echo "Binary not found: $BIN" && exit 1)
            mkdir -p release stage
            cp "$BIN" "stage/${CRATE}"
            chmod +x "stage/${CRATE}"
            tar -C stage -czf "release/${OUT}.tar.gz" "${CRATE}"
            (cd release && shasum -a 256 "${OUT}.tar.gz" > "${OUT}.tar.gz.sha256")
            rm -rf stage

jobs:
  build-linux:
    docker:
      - image: cimg/rust:1.91.0
    environment:
      CRATE_NAME: pet
      TARGET: x86_64-unknown-linux-gnu
      OUT_NAME: pet-linux-x86_64
    steps:
      - checkout
      - run: rustup target add "$TARGET"
      - run: cargo build --release --target "$TARGET"
      - package_and_checksum:
          crate_name: pet
          target: x86_64-unknown-linux-gnu
          out_name: pet-linux-x86_64
      - persist_to_workspace:
          root: .
          paths: [release]

  build-macos:
    macos:
      xcode: "15.4.0"
    environment:
      CRATE_NAME: pet
      TARGET: x86_64-apple-darwin
      OUT_NAME: pet-macos-x86_64
      RUSTUP_HOME: /Users/distiller/.rustup
      CARGO_HOME: /Users/distiller/.cargo
    steps:
      - checkout
      - run:
          name: Install Rust (rustup)
          command: |
            set -euxo pipefail
            if ! command -v rustup >/dev/null; then
              curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
              echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> $BASH_ENV
            fi
            source $BASH_ENV
            rustup default stable
            rustup target add "$TARGET"
      - run:
          name: Build (macOS)
          command: |
            source $BASH_ENV
            cargo build --release --target "$TARGET"
      - package_and_checksum:
          crate_name: pet
          target: x86_64-apple-darwin
          out_name: pet-macos-x86_64
      - persist_to_workspace:
          root: .
          paths: [release]

  publish-release:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - attach_workspace: { at: . }
      - run:
          name: Sanity check token
          command: |
            set -euo pipefail
            : "${CIRCLE_TAG:?CIRCLE_TAG not set}"
            : "${GITHUB_TOKEN:?GITHUB_TOKEN not set}"   # fails fast if project var missing
            # show only presence/length (CircleCI may mask value)
            echo "GITHUB_TOKEN present; length=${#GITHUB_TOKEN}"
      - run:
          name: Create/Update GitHub Release and upload assets (quiet & robust)
          command: |
            set -euo pipefail

            : "${CIRCLE_TAG:?CIRCLE_TAG not set}"
            : "${GITHUB_TOKEN:?GITHUB_TOKEN not set}"

            REPO_SLUG="rishabhpoddar/bitpet-cli"
            TAG="${CIRCLE_TAG}"

            # deps
            if ! command -v jq >/dev/null; then
              sudo apt-get update -y
              sudo apt-get install -y jq >/dev/null
            fi

            api_json() {
              # $1 = method, $2 = url, rest = curl args
              curl -sS -X "$1" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "$2" "${@:3}"
            }

            api_status() {
              # like api_json but returns status code
              curl -sS -o /dev/null -w "%{http_code}" -X "$1" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "$2" "${@:3}"
            }

            # 1) get or create release (suppress 404 noise, handle both cases)
            GET_URL="https://api.github.com/repos/${REPO_SLUG}/releases/tags/${TAG}"
            code=$(api_status GET "$GET_URL")
            if [ "$code" = "200" ]; then
              api_json GET "$GET_URL" > release.json
              echo "Found release for tag ${TAG}"
            elif [ "$code" = "404" ]; then
              echo "No release for ${TAG}; creating…"
              CREATE_URL="https://api.github.com/repos/${REPO_SLUG}/releases"
              api_json POST "$CREATE_URL" \
                -H "Content-Type: application/json" \
                -d "{\"tag_name\":\"${TAG}\",\"name\":\"${TAG}\",\"body\":\"Release ${TAG}\"}" > release.json
            else
              echo "Failed to query release (HTTP $code)"; exit 1
            fi

            RELEASE_ID=$(jq -r '.id // empty' < release.json)
            if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" = "null" ]; then
              echo "Could not obtain release id:"; cat release.json; exit 1
            fi
            echo "Release id: $RELEASE_ID"

            # helper to remove an existing asset by name (to avoid 422 on re-upload)
            delete_asset_if_exists() {
              local name="$1"
              ASSETS_URL="https://api.github.com/repos/${REPO_SLUG}/releases/${RELEASE_ID}/assets?per_page=100"
              assets=$(api_json GET "$ASSETS_URL")
              ASSET_ID=$(echo "$assets" | jq -r --arg n "$name" '.[] | select(.name==$n) | .id' | head -n1)
              if [ -n "${ASSET_ID:-}" ]; then
                echo "Deleting existing asset: $name (id $ASSET_ID)"
                DEL_URL="https://api.github.com/repos/${REPO_SLUG}/releases/assets/${ASSET_ID}"
                code=$(api_status DELETE "$DEL_URL")
                if [ "$code" != "204" ]; then
                  echo "Failed to delete asset $name (HTTP $code)"; exit 1
                fi
              fi
            }

            # 2) upload all artifacts from ./release
            UPLOAD_BASE="https://uploads.github.com/repos/${REPO_SLUG}/releases/${RELEASE_ID}/assets?name="
            shopt -s nullglob
            for f in release/*; do
              [ -f "$f" ] || continue
              name=$(basename "$f")
              delete_asset_if_exists "$name"
              echo "Uploading $name"
              code=$(curl -sS -o /dev/null -w "%{http_code}" -X POST \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$f" \
                "${UPLOAD_BASE}${name}")
              if [ "$code" != "201" ]; then
                echo "Upload failed for $name (HTTP $code)"; exit 1
              fi
            done

            echo "✅ Release ${TAG} published with assets."

workflows:
  version: 2
  release-on-tag:
    jobs:
      - build-linux:
          filters:
            branches: { ignore: /.*/ }
            tags: { only: /.*/ }
      - build-macos:
          filters:
            branches: { ignore: /.*/ }
            tags: { only: /.*/ }
      - publish-release:
          requires: [build-linux, build-macos]
          filters:
            branches: { ignore: /.*/ }
            tags: { only: /.*/ }
